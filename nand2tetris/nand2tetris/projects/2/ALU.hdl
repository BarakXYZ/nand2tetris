// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/2/ALU.hdl
/**
 * ALU (Arithmetic Logic Unit):
 * Computes out = one of the following functions:
 *                0, 1, -1,
 *                x, y, !x, !y, -x, -y,
 *                x + 1, y + 1, x - 1, y - 1,
 *                x + y, x - y, y - x,
 *                x & y, x | y
 * on the 16-bit inputs x, y,
 * according to the input bits zx, nx, zy, ny, f, no.
 * In addition, computes the two output bits:
 * if (out == 0) zr = 1, else zr = 0
 * if (out < 0)  ng = 1, else ng = 0
 */
// Implementation: Manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) sets x = 0        // 16-bit constant
// if (nx == 1) sets x = !x       // bitwise not
// if (zy == 1) sets y = 0        // 16-bit constant
// if (ny == 1) sets y = !y       // bitwise not
// if (f == 1)  sets out = x + y  // integer 2's complement addition
// if (f == 0)  sets out = x & y  // bitwise and
// if (no == 1) sets out = !out   // bitwise not

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the outAdd16.tst output?
    OUT 
        out[16], // 16-bit output
        zr,      // if (out == 0) equals 1, else 0
        ng;      // if (out < 0)  equals 1, else 0

    PARTS:
    Mux16(a=x, b=false, sel=zx, out=postZX); /** Calculate zx */

    Not16(in=postZX, out=notPostZX);
    Mux16(a=postZX, b=notPostZX, sel=nx, out=postNX);

    Mux16(a=y, b=false, sel=zy, out=postZY);  /** Calculate zy */

    Not16(in=postZY, out=notPostZY);
    Mux16(a=postZY, b=notPostZY, sel=ny, out=postNY);
    
    Add16(a=postNX, b=postNY, out=addXY);
    And16(a=postNX, b=postNY, out=andXY);
    Mux16(a=andXY, b=addXY, sel=f, out=postF);
    
    Not16(in=postF, out=notPostF);
    Mux16(a=postF, b=notPostF, sel=no, out=out, out=finalOutput, out[15]=checkNG);
    
    Not16(in=finalOutput, out=notFinalOutput);
    Or16(a=finalOutput, b=notFinalOutput, out=checkZR);
    Inc16(in=checkZR, out[0]=zr0, out[15]=zr15);
    Or(a=zr0, b=zr15, out=zrcheck);
    Not(in=zrcheck, out=zr);

    Mux(a=false, b=true, sel=checkNG, out=ng, out=myng);
}
/**
0000 1111 0101 0111

1111 0000 1010 1000

0000 0000 0010 0000
1111 1111 1110 0000
check first last bit = 1 (positive non-zero, zr=0)

1100 1010 0000 1000
0011 0101 0000 0110


0000 0000 0000 0000
1111 1111 1111 1111

Or(a=in[15], b=notin[15], out=)

1111 1111 0101 0100
+
0000 0000 1010 1000 (NOT)
=
0000 0000 0000 0000

1111 1111 0101 0100
+
0000 0000 1010 1101 (NOT+1)
=
0000 0000 0000 0001

1111 1111 0101 0100
+
0000 0000 1010 1011 (NOT-1)
=
1111 1111 1111 1111


Finally realized I can actually output (out) a few things from the same chip (haha :()
For some reason the Basic Alu test works, but the other one doesn't?
In the website it also works... so... not sure.

Anyways, it was very interesting to implement this one, for some reason the zr & ng took the longest for me.
Also, in this implementation I really realized how powerful is the Mux and how to use it in more ways than I thought.

* BarakXYZ 2024
*/
