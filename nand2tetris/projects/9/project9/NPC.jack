class NPC {
    
    field Array npc;
    field String name, role;
    field int inM, npcIndex;

    static int numOfNPCs;
    static int activeNPC;  // Perhaps needs to be tracked through game?
    static int pendingNPC;
    static ChallengeNode currChallengeNode;
    static ContentNode currContentNode;
    static Array challengeNodeArr, contentNodeArr;
    
    function void init() {
        let numOfNPCs = 0;
        let activeNPC = 0;
        let currChallengeNode = ChallengeNode.makeNode0();
        let currContentNode = ContentNode.makeBlank();

        return;
    }

    function void interact() {
        
        do Debug.interactions();
        // if (pendingNPC = activeNPC) {
            do currChallengeNode.draw();
            do currContentNode.draw();
            do Dialogue.draw();
            do QuestManager.manageQuest();
        // }
        // else {
            // default dialogue of this NPC at this point
        // }

        return;
    }
    
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
    

    method int getStage() {
        return npc[4];
    }

    method void incStage() {
        let npc[4] = npc[4] + 1;  // increment stage by 1
        return;
    }

    function void setPending(int index) {
        let pendingNPC = index;
        return;
    }

    function int getActive() {
        return activeNPC;
    }

    function void setActive(int index) {
        let activeNPC = index;
        // 0 == Shimon
        // 1 == @357
        // 2 == ...
        return;
    }

    function void makeChallengeNode(int quest) {

        if (quest = 0) {
            let currChallengeNode = ChallengeNode.makeNode0();
            do Challenge.setSelBuffIndex(12);
            return;
        }

        if (quest = 1) {
            do currChallengeNode.dispose();
            let currChallengeNode = ChallengeNode.makeNode1();
            do Challenge.setSelBuffIndex(12);
            return;
        }

        if (quest = 2) {
            do currChallengeNode.dispose();
            let currChallengeNode = ChallengeNode.makeNode2();
            do Challenge.setSelBuffIndex(0);
            return;
        }

        if (quest = 3) {
            do currChallengeNode.dispose();
            let challengeNodeArr = Array.new(2);
            let challengeNodeArr[0] = ChallengeNode.makeNode31();
            let challengeNodeArr[1] = ChallengeNode.makeNode32();
            let currChallengeNode = challengeNodeArr[0];
            do Challenge.setSelBuffIndex(12);
            return;
        }

        if (quest = 4) {
            do Memory.deAlloc(challengeNodeArr[0]);
            do Memory.deAlloc(challengeNodeArr[1]);
            do currChallengeNode.dispose();
            do challengeNodeArr.dispose();

            // Make the new node and array

            do Challenge.setSelBuffIndex(0);
            return;
        }

        return;
    }

    function void setChallengeNode(int aIndex) {
        let currChallengeNode = challengeNodeArr[aIndex];
        return;
    }

    function void makeContentNode(int quest) {
        if (quest = 2) {
            let contentNodeArr = Array.new(2);
            let contentNodeArr[0] = ContentNode.makeShimon();
            let currContentNode = contentNodeArr[0];
            return;
        }
        if (quest = 3) {
            let contentNodeArr[1] = ContentNode.make357();
            return;
        }

        return;
    }

    function void setContentNode(int aIndex) {
        let currContentNode = contentNodeArr[aIndex];
        return;
    }

    function boolean checkChallengeAnswer(String a1, String a2, String a3) {
        var boolean ret;
        if (~(currChallengeNode.isCompleted())) {
            let ret = currChallengeNode.checkAnswer(a1, a2, a3);
            do Output.moveCursor(0,0);
            if (ret) {
                if (currChallengeNode.isEnemy()) {
                    do currContentNode.reveal(a1);
                    do currChallengeNode.complete();
                }
                else { do QuestManager.complete(); }  // main quest
            }
            else { do UserInterface.signalIncorrectAnswer(); }
            return ret;
        }
        else { return false; }  // keeps cursor in buffer
    }

    function boolean isEnemyDefeated() {
        return currChallengeNode.isCompleted();
    }
}
