class Sprites {

//** Sprite Selection Map:
// 0 == Shimon | 1 == Gini | 2 == ? | 3 == ? | *//
static int currentSelSprite;

static int shimonBigCoord, giniBigCoord;
static int questionMarkCoord1, questionMarkCoord2, questionMarkCoord3;
static int shimonSmallCoord, giniSmallCoord;

function void init() {
	
    let currentSelSprite = 0;
	
    // let shimonSmallCoord = 6333;
    let shimonSmallCoord = 7165;
    let giniSmallCoord = 5148;

    // let shimonBigCoord = 1899;
    let shimonBigCoord = 1739;
    let giniBigCoord = 1482;

    let questionMarkCoord1 = 5341;
    let questionMarkCoord2 = 3485;
    let questionMarkCoord3 = 1501;
    return;
}

function void setCurrentSprite(int sel) {
    let currentSelSprite = sel;
    return;
}

function int getCurrentSprite() {
    return currentSelSprite;
}

function void drawCurrentSelSprite(boolean cond) {
    var int activeNPC;
    let activeNPC = NPC.getActive();

    if (activeNPC = 0) { do Sprites.drawSpriteShimon(~cond); return; }
    if (activeNPC = 1) {
        if (~(NPC.isEnemyDefeated())) { do Sprites.drawEnemy(~cond);}
        else { do Sprites.drawHappyFlower(~cond);}
        return;
    }
    return;
}


//** Viewport is at x1=134, y1=46, x2=354, y2=174 
//   We're essentially offesting by 1 pixel to not override the frame itself. 
//	 and on top of that, offseting by a few pixels to not override the sel arrow */
function void clearViewport() {

    do Screen.setColor(false);
    do Screen.drawRectangle(144, 47, 353, 173);
    do Screen.setColor(true);

    return;
}


// Draw Shimon Big & Small
function void drawSpriteShimon(boolean isFlipped) {
    if (isFlipped) { do SpriteShimon.drawShimonBig(shimonBigCoord); }
    else { do SpriteShimon.drawShimonBigFlipped(shimonBigCoord); }
    return;
}

function void drawSpriteShimonSmall() {
    do SpriteShimon.drawShimonSmall(shimonSmallCoord);
    return;
}


// Draw Gini Big & Small
function void drawSpriteGini(boolean isFlipped) {
    if (isFlipped) { do SpriteGini.drawGiniBig(giniBigCoord); }
    else { do SpriteGini.drawGiniBigFlipped(giniBigCoord); }
    return;
}

function void drawSpriteGiniSmall() {
    do SpriteGini.drawGiniSmall(giniSmallCoord);
    return;
}

// Draw Question Mark
function void drawQuestionMark1() {
    do SpriteQuestionMark.drawQuestionMark(questionMarkCoord1);
    return;
}

// Draw Question Mark
function void drawQuestionMark2() {
    do SpriteQuestionMark.drawQuestionMark(questionMarkCoord2);
    return;
}

// Draw Question Mark
function void drawQuestionMark3() {
    do SpriteQuestionMark.drawQuestionMark(questionMarkCoord3);
    return;
}

// Draw enemy (challenge 3 reg357)
function void drawEnemy(boolean isEyeOpened) {
    var int x, y, offY, offMouthX, offMouthY, spikiness, direction, length;
    var int hornWidth, hornsOffY;
    let x = 240;
    let y = 110;
    let offY = 12;
    let offMouthX = 20;
    let offMouthY = 14;
    let spikiness = 2; // Higher value for more spiky, lower for less
    let direction = 1; // 1 for right rotation, -1 for left rotation
    let length = 50;   // Length of the horns
    let hornWidth = 40; // Distance between the horns
    let hornsOffY = -55;  // Vertical offset of the horns

    do Sprites.drawTriangle(30, x, y - 60, spikiness, direction, true);  // Middle Horn
    // do Sprites.drawHorn(x - hornWidth, y + hornsOffY, direction, length);  // L
    // do Sprites.drawHorn(x + hornWidth, y + hornsOffY, -direction, length);  // R

    // body
    do Screen.setColor(true);
    do Screen.drawCircle(x, y, 40);
    do Screen.setColor(false);
    do Screen.drawCircle(x, y, 37);

    do Sprites.drawEnemyEye1(isEyeOpened, x, y, offY, 1);

    // Mouth
    do Screen.setColor(true);
    do Screen.drawRectangle(x-offMouthX, y+offMouthY, x-offMouthX+45, y+offMouthY+2);
    // Teeth
    do Screen.drawRectangle(x-10, y+offMouthY, x-4, y+offMouthY+10);
    do Screen.setColor(false);
    do Screen.drawRectangle(x-8, y+offMouthY+2, x-6, y+offMouthY+10-2);

    return;
}

//** Radius -> bigger value for smaller eye, 1 for regular size *//
function void drawEnemyEye1(boolean isOpened, int x, int y, int offY, int radius) {
    // Eye
    do Screen.setColor(true);
    do Screen.drawCircle(x, y - offY, 14 / radius);
    
    // Stroke
    do Screen.setColor(false);
    do Screen.drawCircle(x, y - offY, 12 / radius);
    do Screen.setColor(true);

    if (isOpened) { do Screen.drawCircle(x, y - offY, 5 / radius); }  // inner
    else { do Screen.drawRectangle(x-12, y-14, x+12, y-13); } // closed

    return;
}

function void drawTriangle(int size, int x, int y, int spikiness, int dir, bool draw) {
    var int i;
    do Screen.setColor(draw);
    let i = 0;
    while (i < size) {
        do Screen.drawRectangle(x - ((i / spikiness) * dir), y + i, x + ((i / spikiness) * dir), y + i + 1);
        let i = i + 1;
    }
    return;
}

function void drawUpsideTriangle(int size, int x, int y, int spikiness, int dir, bool draw) {
    var int i;
    var int offset;
    var int startX;
    var int endX;
    
    do Screen.setColor(draw);
    let i = 0;
    while (i < size) {
        let offset = (i / spikiness) * dir;
        let startX = x - offset;
        let endX = x + offset;
        
        // Draw rectangle line by line, correcting for possible illegal coordinates
        if (startX < 0) {
            let startX = 0;
        }
        if (endX > 511) {
            let endX = 511;
        }
        if (y - i > 0) {
            do Screen.drawRectangle(startX, y - i, endX, y - i + 1);
        }

        let i = i + 1;
    }
    return;
}


function void drawHorn(int x, int y, int direction, int length) {
    do Screen.setColor(true);
    // Line 1
    do Screen.drawLine(x, y, x + (30 * direction), y + length);
    // Line 2
    do Screen.drawLine(x, y, x + (15 * direction), y + (length - 10));
    // Line 3
    do Screen.drawLine(x, y, x + (20 * direction), y + (length - 30));
    return;
}

function void drawHappyFlower(boolean switch) {

    var int x, y, offX1, offY1, offX2, offY2, r1, r2;
    let x = 240;
    let y = 110;

    // let offX1 = 12;
    let offY1 = 40;
    let offX2 = 34;
    let offY2 = 20;

    let r1 = 22;
    let r2 = 20;

    // Draw Petals
    do Sprites.drawPetal(x, y - offY1, r1, r2);  // Top Petal
    do Sprites.drawPetal(x, y + offY1, r1, r2);  // Bottom Petal
    do Sprites.drawPetal(x + offX2, y - offY2, r1, r2);  // Top Right Petal
    do Sprites.drawPetal(x - offX2, y - offY2, r1, r2);  // Top Left Petal
    do Sprites.drawPetal(x + offX2, y + offY2, r1, r2);  // Bot Right Petal
    do Sprites.drawPetal(x - offX2, y + offY2, r1, r2);  // Bot Left Petal

    // body
    do Screen.setColor(true);
    do Screen.drawCircle(x, y, 40);

    // Face
    if (switch) { do Sprites.drawFlowerFace(23, 15, x, y, 2, 1); }
    else { do Sprites.drawFlowerFace(23, 10, x, y, 1, 1); }

    return;
}

function void drawPetal(int x, int y, int r1, int r2) {
    do Screen.setColor(true);
    do Screen.drawCircle(x, y, r1);
    do Screen.setColor(false);
    do Screen.drawCircle(x, y, r2);
    return;
}

function void drawFlowerFace(int s1, int s2, int x, int y, int spikiness, int dir) {
    let y = y + 35;
    do Sprites.drawUpsideTriangle(s1, x, y, spikiness, dir, false);
    do Sprites.drawUpsideTriangle(s1, x, y - 4, spikiness, dir, true);

    let y = y - 62;
    do Sprites.drawTriangle(s2, x - 12, y, spikiness, dir, false);
    do Sprites.drawTriangle(s2, x - 12, y + 2, spikiness, dir, true);

    do Sprites.drawTriangle(s2, x + 12, y, spikiness, dir, false);
    do Sprites.drawTriangle(s2, x + 12, y + 2, spikiness, dir, true);

    return;
}

}
