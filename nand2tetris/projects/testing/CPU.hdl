// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/5/CPU.hdl
/**
 * The Hack Central Processing unit (CPU).
 * Parses the binary code in the instruction input and executes it according to the
 * Hack machine language specification. In the case of a C-instruction, computes the
 * function specified by the instruction. If the instruction specifies to read a memory
 * value, the inM input is expected to contain this value. If the instruction specifies
 * to write a value to the memory, sets the outM output to this value, sets the addressM
 * output to the target address, and asserts the writeM output (when writeM = 0, any
 * value may appear in outM).
 * If the reset input is 0, computes the address of the next instruction and sets the
 * pc output to that value. If the reset input is 1, sets pc to 0.
 * Note: The outM and writeM outputs are combinational: they are affected by the
 * instruction's execution during the current cycle. The addressM and pc outputs are
 * clocked: although they are affected by the instruction's execution, they commit to
 * their new values only in the next cycle.
 */
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:

    // if inst[15] == 1, it's a C-inst -> alu_out = A-Reg
    // else it's an A-inst -> instruction = A-Reg
    Mux16(a=instruction, b=alu_out, sel=instruction[15], out=mux_inst_alu);

    Mux(a=instruction[3], b=instruction[3], sel=false, out=writeM);
    // Instruction 3 == writeM (RAM[A])

    ARegister(in=mux_inst_alu, load=instruction[5], out=reg_a, out[0..14]=addressM);
    // ?Questioning the addressM at this point specifically?

    DRegister(in=alu_out, load=instruction[4], out=reg_d);
    // Getting input from the ALU, control-bit taken from the instruction 'dest' c-bit 4

    Mux16(a=inM, b=reg_a, sel=instruction[15], out=mux_inM_regA);
    // ?? Big question on the sel bit here ??

    ALU(x=reg_d, y=mux_inM_regA,
        zx=instruction[11], nx=instruction[10],
        zy=instruction[9], ny=instruction[8],
        f=instruction[7], no=instruction[6],
        zr=out_zr, ng=out_ng,
        out=alu_out, out=outM);


    // ----------------------------------------
    // Setting all possible jump-conditions:

    // Unconditional No-jump == false == null == 000 (set directly as false in DMux)
    // Unconditional Do-jump == true == JMP == 111 (set directly as true in DMux)

    // ALU's zr & ng (control bits)
    // out_zr is simply == 0 -> JEQ == 010
    // out_ng is simply < 0 -> JLT == 100

    Or(a=out_zr, b=out_ng, out=zr_or_ng);  // <= 0 -> JLE == 110
    Not(in=zr_or_ng, out=not_zr_or_ng);  // > 0 -> JGT == 001

    Not(in=out_ng, out=not_ng);
    Or(a=not_ng, b=out_zr, out=not_ng_or_zr);  // >= 0 -> JGE == 011
    Not(in=out_zr, out=not_zr);  // != 0 -> JNE == 101


    // Check if both 000
    And(a=instruction[0], b=instruction[1], out=inst01);
    And(a=inst01, b=instruction[2], out=jump);

    // ----------------------------------------

    Not(in=jump, out=not_jump);
    PC(in=reg_a, inc=not_jump, load=jump, reset=reset, out[0..14]=pc);
}


/**

    Mux8Way(
        a=false, b=not_zr_or_ng, c=out_zr, d=not_ng_or_zr,
        e=out_ng, f=not_zr, g=zr_or_ng, h=true,
        sel=instruction[0..2],
        out=jump);


    // Check if 'reset' is asserted, and override (jump to 0) if so
    Mux(a=jump_out, b=true, sel=reset, out=pc_control);  // if reset -> must load
    Mux16(a=reg_a, b=false, sel=reset, out=pc_input);  // if reset -> must jump to 0

8-bits of conditions, that if we add together, will represent the current ALU calculation (Greater than 0, equals, etc.)

3-bits of the actual jump control bits subset, that are given by the instruction register.

We want to check if they match, if they match we jump, else, no jump (of course, this behavior is overriden by the 'reset' bit)

I'd would say, that essentially what we need, is a method to compare them both.
Perhaps a chip that:
1. will accept 8 different bits, combining them together to 3-bits (ALU output)
2. will accept 3-bits as is (Instruction memory)
3. Compare them and output 1 if exact match, else 0.
*/

